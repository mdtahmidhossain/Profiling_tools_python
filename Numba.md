### Numba
Numba is a just-in-time (JIT) compiler for Python code, especially for numerical and array-oriented code. It allows you to speed up your Python code by compiling it to machine code, which runs much faster than Python's interpreted code. With Numba, you can take advantage of the performance gains of compiled code without having to write any C or other low-level code.

Numba supports a subset of the Python language, including NumPy arrays and numerical operations, and can be used as a drop-in replacement for parts of your Python code that need to be optimized. You simply decorate the functions you want to compile with the **numba.jit **decorator, and Numba takes care of the rest.

In addition to its JIT compiler, Numba also provides a set of libraries for GPU programming, making it easy to write GPU-accelerated code in Python.

### To install Numba
```shell
pip install numba
```
### Here's an example to show the difference in speed between Numba and pure Python
```python
import numba
import numpy as np
import time

def calculate_mean(arr):
    """
    Calculate the mean of a NumPy array.

    Parameters
    ----------
    arr : numpy.ndarray
        The input array.

    Returns
    -------
    float
        The mean of the input array.
    """
    sum = 0
    for i in range(arr.shape[0]):
        sum += arr[i]
    return sum / arr.shape[0]

@numba.jit
def calculate_mean_numba(arr):
    """
    Calculate the mean of a NumPy array using Numba.

    Parameters
    ----------
    arr : numpy.ndarray
        The input array.

    Returns
    -------
    float
        The mean of the input array.
    """
    sum = 0
    for i in range(arr.shape[0]):
        sum += arr[i]
    return sum / arr.shape[0]

def main():
    """
    Main function to compare the speed of the two mean calculation functions.
    """
    # Generate an array of random numbers
    arr = np.random.rand(1000000)

    start = time.time()
    mean = calculate_mean(arr)
    end = time.time()
    print("Mean (Pure Python):", mean)
    print("Time (Pure Python):", end - start, "seconds")

    start = time.time()
    mean = calculate_mean_numba(arr)
    end = time.time()
    print("Mean (Numba):", mean)
    print("Time (Numba):", end - start, "seconds")

if __name__ == "__main__":
    main()

```
I will start testing with **1000000**
#### Output:
    Mean (Pure Python): 0.5002930808103765
    Time (Pure Python): 0.07777571678161621 seconds
    Mean (Numba): 0.5002930808103765
    Time (Numba): 0.12022900581359863 seconds

It looks like the output you posted is the result of running the code I provided. The mean values of the arrays generated by both functions are the same, as expected.

Regarding the time, it looks like the pure Python function is faster than the Numba function in this case. This is surprising, as Numba is typically faster than pure Python for numerical computations. It's possible that the overhead of JIT compiling the Numba function is greater than the speedup from Numba optimization in this particular case.

It's also possible that the input array size is too small to see a significant speedup from Numba. You can try increasing the size of the input array to see if the difference in performance becomes more pronounced.

Now, I tried with **1000000000**.
#### Output:
    Mean (Pure Python): 0.5000109485810165
    Time (Pure Python): 81.67988801002502 seconds
    Mean (Numba): 0.5000109485810165
    Time (Numba): 2.5274059772491455 seconds

It looks like in this case, Numba is significantly faster than pure Python. The mean values generated by both functions are still the same, which is what we expect.

The **pure Python function took 81.67 seconds** to run, while the **Numba function took only 2.52 seconds** to run. This shows that Numba is able to significantly speed up the calculation of the mean.

It's possible that increasing the size of the input array would lead to an even greater difference in performance between the two functions.
